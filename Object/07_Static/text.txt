インポートというのが、このプログラムで使うから事前に準備をしておくための記述で、
インポートしておいたクラスを実際に組み立てて使用するのがインスタンス化といいますよね。

インポートというのが、山札から手札にカードを食らえることになり
インスタンス化というのが、手札からフィールドゾーンへカードを召喚するということになりましたよね。

ちなみにインポートしている設計図の状態のものをクラスオブジェクトといいます。
そしてインスタンス化しているものをインスタンスオブジェクトといいます。

クラスobjectはインポートすることでそのクラスが存在するパス（場所）をメモリに格納する参照型となります。

そのほかにもクラスオブジェクトで管理されるのは、
static修飾子ありのフィールドとメソッドです。
逆にstatic修飾子なしのフィールドとメソッドはクラスオブジェクトではなく、インスタンスオブジェクトで管理されます。
どういうことかというと、
インスタンスオブジェクトのように個別のオブジェクトごとに内容が異なるものはstaticが付いていないので、インスタンスオブジェクトごとに
管理する必要がありますよね。

でも、staticがついている場合は、インスタンスオブジェクトごとではなくクラス単位で共通して使えるのです。

staticがついているものを静的メンバといいます。
つまり変更されることがないということですね。
インスタンス化後もコロコロ値が変わらないので、インスタンス後は変更する必要がないということですね。
static が付いた変数のことはクラス変数といいます
またメソッドのことはクラスメソッドといいまス。

でクラスメソッドとクラス変数は何ができるのかというと、インスタンスで管理されていないということは、
インスタンス化しなくても使用できるということです。
クラスオブジェクトはインポートした時点で出来上がっているので、
つまりどういうことかというと、クラスオブジェクトで管理されることになる、staticが付いた、クラス変数やクラスメソッドは定義されている
ということになります。だからこそインスタンス化しなくても使えるのです。
インスタンス化しなくても使えるということは、インスタンスに対して使うものではないということですね。

staticが付いたメンバー同士でしかアクセスできません。
もしstaticのメソッドがstaticのついていないフィールドを持ってこようとしても、まだ存在していないから、アクセスすることができません。

呼び出し方なんですけど
Sample2_06_1_Dog.SCIENTIFIC_NAMEというように直接クラス名を書いてそのあとに変数名をつけることで、呼び出せます。

このstaticはどういうときに使うのかというと、
クラス全体の状況を確認するときとかに使います。

dogクラスがあって、インスタンス化するたびに数を増やしていくことで、インスタンス化した数を確認できます。
またそのインスタンス化によるカウント数を表示するためのメソッドも必要です。
これらはインスタンスオブジェクト内で管理されてしまうと、インスタンスによって数字が分かれてしまいます。

ですが、クラス変数として、カウント数を増やすことで、クラスで一括で管理できます。
さらに、クラスメソッドを使えば、常に最新の情報を得ることができます。

こういったように、クラス全体の情報を管理するときにstaticは役に立ちます。

ちなみにstaticのメンバーはstaticではないメンバーから呼び出すことはできませんが、
クラスオブジェクトだけではなく、インスタンスオブジェクトから呼び出すこともできます。
Dog.getNumber()というようにクラスオブジェクトでインスタンス化のカウントを呼び出せますが、
Dog dog1 = new Dog()でインスタンス化して
dog01.getNumber()　というようにインスタンスオブジェクトに対しても呼び出せます。
このgetNumber()はどのインスタンスに対して行っても共通の戻り値を取得できます。
staticのフィールドを変更するクラスオブジェクトをインスタンスオブジェクトに行った場合は
すべての同じクラスのインスタンス化オブジェクトが共通で変更されます。

”クラスメンバーはインスタンスのメンバーのように呼び出すことができる。

ちなみにコンストラクター内でのみstaticのメンバーを呼び出すことができる。

クラスオブジェクトは設計図だから、
せっけいずのじてんで、へんすうや、めそっどがメモリに格納されているので、インスタンス化して実体化させなくても変数やメソッドを使うことができる。

カードゲームで言うと手札から召喚しなくても、手札にあるだけで効果を発揮するようなイメージですね。

インスタンスで管理している内容を個人のノートとすると
クラスオブジェクトで管理している内容や黒板と考えてください。
ノートの内容を書き換えても、クラスﾒｲﾄのノートの内容は変わりません。
しかし、黒板を書き換えると、クラスメイト全員が見る情報は黒板は共通のため、
変わってしまいます。

誰か一人が、黒板を消してしまうと、誰もノートに記録していないので、何が書いてあったかわからないという状況ですね。


で、mainメソッドにはなぜstaticが用いられるのかという理由について説明しますね。

mainを実行するときは、実際にはJVMが動かしているので、
JVMがmainを実行するためには、mainが記述されているクラスを読み込んだ時点で、メモリにmainメソッドが格納されている必要があります。
そのためにはクラスメソッドにする必要があるので、staticをつける必要があります。
staticにすることでプログラムが終わるまでメモリ上にずっと存在するので、いつでもmainメソッドが実行できるようになります。


なんでもかんでもstaticをつけるのはやめましょう
staticをつけるというのは、メモリ上に保管することになるので、よくわからんかったらstaticつけたら動いたというのはよくありません。
mainはstaticのため、同じクラスでもstaticではないメソッドを実行しようとすると、エラーになるから、メソッドもstaticをつけることで解決はするが、
常に使うわけではないメソッドをメモリに入れておくことになるため無駄なメモリを使うことになります。

mainメソッドはstaticで、staticではないメソッドを呼び出そうとするときに、
メソッド名()としてしまうと、このメソッド名()はインスタンスメソッドなので、呼び出せません、
なので、このメソッドをstaticにしてしまうと動きはしますが正しくはないやりかたです。
正しくは一度このmainメソッド内で、クラスをインスタンス化してインスタンスを格納した変数名.メソッド名()として呼び出すのが正しいです。

しかし、mainメソッドが存在するクラス内で、自身のクラスをインスタンス化してインスタンス化メソッドを呼び出すという書き方がよくありません

インスタンス化しないクラスにはstaticだけで済む設計にする
インスタンス化前提のクラスにはstaticなしの設計を考える

