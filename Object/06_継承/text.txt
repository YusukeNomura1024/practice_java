オーバーライドというのがありますけど、
戻り値と引数とメソッド名が全く同じものが
スーパークラスとサブクラスに存在する場合、どちらが優先されるのかというと
サブクラスの方が優先されます。

例えば、カークラスではスピード制限を180キロにしているが、
トラッククラスではスピード制限を80キロにしている場合は、
トラッククラスのメソッドが優先される

public void accelerator(){
    if(super.getSpeed() < 80){
        super.setSpeed( super.getSpeed() + 1);
    }
}

実際の機構としては、メソッドが実行されたときに、親クラスではなく、サブクラスからそのメソッドに該当するものを探しに行く
ので、サブクラスに一致するメソッドがあれば、その時点で、探索を終了するため、スーパークラスの探索はされないため、サブクラスが優先されることになる。

また、コンストラクタ―がないクラスは、それでも自動でからのコンストラクターが実行されますが、
このクラスのスーパークラスにコンストラクターがある場合は、自動で呼び出されるので注意が必要である。
super();として実行される

サブクラスのメソッド内で、スーパークラスのメンバを呼び出す場合は、superを使う
現在のクラスのメンバを呼び出す場合は、thisだが、スーパークラスのメンバを呼び出すにはsuperを使う
ちなみにスーパークラスで設定されたメンバーはthisでも呼び出せるが、
サブクラスとスーパークラスで同じ名前のものがある場合は、サブクラスが優先されるため、
サブクラスで、スーパークラスのメソッドに追記したい場合は、superを使ってまずスーパークラス通りの処理を実行した後に、
サブクラス用の処理を付け加えることができる。

ちなみに、スーパークラスでprivateに設定されているメンバーはサブクラスでは引き出すことができない。
ただし、スーパークラスでprivateになっているメソッドを呼び出して、そのメソッドの中で、スーパークラスのフィールドを呼び出すことはできる。

private String speed は呼び出せないが
public String getSpeed(){
    this.speed
}
protectedであれば、サブクラスのみで呼びさせる

サブクラスでスーパークラスのフィールドを呼び出せないため、
サブクラスではスーパークラスで作ったgetterメソッドを使って、値を呼び出す必要がある。
このとき、super.getterメソッドでもいいし、this.getterメソッドでいいし、何もつけずにgetterメソッドを使っても問題はないが、
わかりやすくするために、スーパークラスのものを使っているのであれば、super.getterメソッドと記述する
