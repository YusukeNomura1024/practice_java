abstractという抽象クラスについての説明ですね

このクラスを継承したサブクラスには○○というクラスメソッドがあるべきだ
という仕様のみを定義した継承前提のクラスを抽象クラスといいます。

例えば、Dogという抽象クラスがあるとして、このDog
クラスは犬種ごとのクラスのスーパークラスになる予定で、
ただの犬というインスタンスは生成しない。
このDogクラスを継承するすべての犬種クラスは
吠えるというメソッドを実装するべきであるということで、
吠える党メソッドを定義することをサブクラスに強要することになります。
このDogクラス自体には吠えるというクラスメソッドはメモリには入りません。
しかし、サブクラスではこの吠メソッドを必ずoverriddeして
処理内容を記述しないといけないようになります。

インスタンス化させることがない（実体化させることがない）
抽象的なクラスだと覚えておきましょう。

車であれば、継承されるサブクラスにはこんな機能があるべきだ
※ただし具体的な処理内容はオーバーライドして定義してねという感じですね。
accelerator(),brake(),paint()など
｛｝で処理を記述せずに、引数までだけの記述

でこの指定したメソッドを必ずオーバーライドしないとエラーになってしまいます。

継承したサブクラスをインスタンス化したときに、
サブクラスに、brakeメソッドがなかったら、それは不良クラスになってしまい
実装できません。

これをやるメリットとしては、
継承先のクラスで、必ず同名のメソッドが実装されることを前提にできます。
アクセルメソッドを実装するときに、
あるサブクラスはaccelerator()として
別のサブクラスはspeedUp()としてしまうと、
のちの処理で面倒になってしまいます。

そうならないように、メソッド名を制限して、必要なメソッドを指定
することができます。

abstract void accelerator();
としておくと、
戻り値はvoidで、メソッド名はacceleratorで、引数はなし
というメソッドを必ず実装することになります。
オーバーライドで戻り値の型を変えたり、引数を加えたり
はできません。


abstract class Sample2_07_1_AbstractTruck {
というようにabstract　と書いてからclassを定義します。


で、その中にもabstract付きのメソッドを定義します。

abstract void accelerator() ;
中かっこをつけない代わりに、;でしっかりと終わらせます。


、で抽象クラスは、継承されるためだけのクラスになるので
インスタンス化しようとするとエラーになります。

抽象メソッドはオーバーライドを使用されること前提とします。
抽象メソッドをオーバーライドして具体的な処理内容を定義することを
実装といい、抽象クラスを継承して作成されてインスタンス内に
実装されていない中小メソッドが
1つでもあればインスタンス化の際にエラーとなります。
抽象クラスを継承した全クラスに抽象メソッドの実装を共生することができるため、
そのクラスで定義すべき機能が漏れたり、好き勝手な書き方で定義されないように
抑制できるといったメリットがあります。

続いてポリモーフィズムについてです。
具体的な指示をしなくても、プログラムが最適な処理を行ってくれる？ことですね
オーバーロードやオーバーライドに使われています。

オーバーロードだと引数が違えば一つのクラス内に同じメソッド名の
メソッドを実装することができましたよね。

引数が文字列であれば、このメソッド、引数がintであればこのメソッッド
という感じですね。

これは、プログラム側が、適切に判断をしてどのメソッドを実行するのかを
決めてくれています。

オーバーライドも、サブクラスから同じメソッド名を探して、
サブクラスになければその上のスーパークラスから探すというように
探し方も適切な順番で行ってくれます。

こういった、プログラミング側の判断に任せて、
処理が変更されるように設定することができるのは、
記述の省略にもつながるので
ポリモーフィズムは便利ですよね

本来条件分岐はifやswitchを使って
指定しなければいけませんが、
オーバーライドやオーバーロードに関しては、
その条件分岐を細かく指示しなくても、
プログラムが判断してくれます。
このように、条件分岐で指定をしなくても、判断してくれる
機能がポリモーフィズムということになりますね。

printlnもどんなオブジェクトを放り込んでも表示してくれますが、
ポリモーフィズムのおかげでどんな引数も放り込むことができている。

なのでポリモーフィズムを意識して記述すことで、
条件分岐のような面倒な指示を省略して、
プログラムに判断を任せることができるので便利です。



次は例外処理ですね。

エラーにはいくつか種類があるのですが
コンパイルエラーや論理エラー（バグ）
論理エラーとは予想した処理と異なる結果が返ってくることですね。

そして最後に例外というのがあります。
この例外が起きたときにプログラムを止めずに継続して実行させることを
例外処理といいます。

例外が発生したときに、プログラムを停止しなくても継続可能
なのであれば、続行させるようにできます。

ユーザーが変な入力をしてきたときに、
例外が発生した旨を伝えたりもできる。

例外を監視して、もし例外が起こった場合は、
強制終了をせずに適切な処理を行ってそのまま
処理を継続させます。

try~catch構文です。

int型の入力を期待しているのに、
String型の入力をされてしまった時のことを考えて
int型以外の型でエラーが起きたときは、すべて０として処理するなど

