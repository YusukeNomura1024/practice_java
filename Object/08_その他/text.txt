abstractという抽象クラスについての説明ですね

このクラスを継承したサブクラスには○○というクラスメソッドがあるべきだ
という仕様のみを定義した継承前提のクラスを抽象クラスといいます。

例えば、Dogという抽象クラスがあるとして、このDog
クラスは犬種ごとのクラスのスーパークラスになる予定で、
ただの犬というインスタンスは生成しない。
このDogクラスを継承するすべての犬種クラスは
吠えるというメソッドを実装するべきであるということで、
吠える党メソッドを定義することをサブクラスに強要することになります。
このDogクラス自体には吠えるというクラスメソッドはメモリには入りません。
しかし、サブクラスではこの吠メソッドを必ずoverriddeして
処理内容を記述しないといけないようになります。

インスタンス化させることがない（実体化させることがない）
抽象的なクラスだと覚えておきましょう。

車であれば、継承されるサブクラスにはこんな機能があるべきだ
※ただし具体的な処理内容はオーバーライドして定義してねという感じですね。
accelerator(),brake(),paint()など
｛｝で処理を記述せずに、引数までだけの記述

でこの指定したメソッドを必ずオーバーライドしないとエラーになってしまいます。

継承したサブクラスをインスタンス化したときに、
サブクラスに、brakeメソッドがなかったら、それは不良クラスになってしまい
実装できません。

これをやるメリットとしては、
継承先のクラスで、必ず同名のメソッドが実装されることを前提にできます。
アクセルメソッドを実装するときに、
あるサブクラスはaccelerator()として
別のサブクラスはspeedUp()としてしまうと、
のちの処理で面倒になってしまいます。

そうならないように、メソッド名を制限して、必要なメソッドを指定
することができます。

abstract void accelerator();
としておくと、
戻り値はvoidで、メソッド名はacceleratorで、引数はなし
というメソッドを必ず実装することになります。
オーバーライドで戻り値の型を変えたり、引数を加えたり
はできません。


abstract class Sample2_07_1_AbstractTruck {
というようにabstract　と書いてからclassを定義します。


で、その中にもabstract付きのメソッドを定義します。

abstract void accelerator() ;
中かっこをつけない代わりに、;でしっかりと終わらせます。


、で抽象クラスは、継承されるためだけのクラスになるので
インスタンス化しようとするとエラーになります。

抽象メソッドはオーバーライドを使用されること前提とします。
抽象メソッドをオーバーライドして具体的な処理内容を定義することを
実装といい、抽象クラスを継承して作成されてインスタンス内に
実装されていない中小メソッドが
1つでもあればインスタンス化の際にエラーとなります。
抽象クラスを継承した全クラスに抽象メソッドの実装を共生することができるため、
そのクラスで定義すべき機能が漏れたり、好き勝手な書き方で定義されないように
抑制できるといったメリットがあります。

続いてポリモーフィズムについてです。
具体的な指示をしなくても、プログラムが最適な処理を行ってくれる？ことですね
オーバーロードやオーバーライドに使われています。

オーバーロードだと引数が違えば一つのクラス内に同じメソッド名の
メソッドを実装することができましたよね。

引数が文字列であれば、このメソッド、引数がintであればこのメソッッド
という感じですね。

これは、プログラム側が、適切に判断をしてどのメソッドを実行するのかを
決めてくれています。

オーバーライドも、サブクラスから同じメソッド名を探して、
サブクラスになければその上のスーパークラスから探すというように
探し方も適切な順番で行ってくれます。

こういった、プログラミング側の判断に任せて、
処理が変更されるように設定することができるのは、
記述の省略にもつながるので
ポリモーフィズムは便利ですよね

本来条件分岐はifやswitchを使って
指定しなければいけませんが、
オーバーライドやオーバーロードに関しては、
その条件分岐を細かく指示しなくても、
プログラムが判断してくれます。
このように、条件分岐で指定をしなくても、判断してくれる
機能がポリモーフィズムということになりますね。

printlnもどんなオブジェクトを放り込んでも表示してくれますが、
ポリモーフィズムのおかげでどんな引数も放り込むことができている。

なのでポリモーフィズムを意識して記述すことで、
条件分岐のような面倒な指示を省略して、
プログラムに判断を任せることができるので便利です。



次は例外処理ですね。

エラーにはいくつか種類があるのですが
コンパイルエラーや論理エラー（バグ）
論理エラーとは予想した処理と異なる結果が返ってくることですね。

そして最後に例外というのがあります。
この例外が起きたときにプログラムを止めずに継続して実行させることを
例外処理といいます。

例外が発生したときに、プログラムを停止しなくても継続可能
なのであれば、続行させるようにできます。

ユーザーが変な入力をしてきたときに、
例外が発生した旨を伝えたりもできる。

例外を監視して、もし例外が起こった場合は、
強制終了をせずに適切な処理を行ってそのまま
処理を継続させます。

try~catch構文です。

int型の入力を期待しているのに、
String型の入力をされてしまった時のことを考えて
int型以外の型でエラーが起きたときは、すべて０として処理するなど

ちなみに例外にもクラスが存在します。

エラーが起きたときは、例外クラスが発生します。
例外の種類によって対応するクラスが異なります。
数字出ない値が渡されたときは
NumberFormatExceptionクラスが対応します。

try{}でカッコ内で例外が起こる可能性のある処理を記述して
catch(){} で
()内には例外処理の引数を設定して
｛｝内にはその例外の時に処理する内容を記述します。
｛｝内では引数で渡した例外クラスを呼び出すこともできます。

引数に例外クラスを渡すことで、
一時的にcatch内では例外クラスをインスタンスとして扱うことができます。
何行目に例外が発生しているのかというのも例外オブジェクトに詰め込まれていますので、
それを取り出すことができます。

catchの引数によって処理を分岐させるのは
まさしくオーバーロードでありポリモーフィズムですね。

また、例外クラスにもメソッドが用意されています

printStackTrace()
実行すると例外が発生するまでの経路を画面に表示してくれます。
バグの特定に役立ちます。

ちなみにtryの中で呼び出したメソッドがエラーになれば
例外が発生することになりますが、
呼び出したメソッドの中でも例外処理を行っていた場合、
そのメソッドの中では例外処理がされてプログラムが継続されるため、
そのメソッドを呼び出したクラス内では例外が発生したことには
なりません。
もし呼び出したメソッド内で例外処理をしていなかった場合は
呼び出し元のクラスの例外処理が呼ばれることになります。


try~catchに続けて
finalyブロックがあり、例外が発生しようがしまいが最後に必ず
実行する処理を記述できます。

多くの使用される場合では、
処理終了後に行うシステム処理（ネットワークやデータベースの切断）
やメモリの開放が記述されます。
また、finallyブロックではreturnの使用が禁止されています。
例外が発生してもこれだけはやっておかないといけないことを記述します。

あとはthrows節というのもあります。
定義したメソッドに続けてthrowsを使うことで、
メソッドを呼び出すときに指定した例外処理を必ず
記述しないといけないようにすることができます。
throwsにより指定した例外を想定した例外処理が記述されていない場合は
コンパイルエラーとなります。
いわゆるおせっかいというやつですね。
public FileReader( String filename) throws FileNotFoundException{
    例外時の処理
}
という書き方をすることで、
別のクラスからFileReader()を呼び出すときに
FileReaderメソッドがtryの中で呼び出されており、
なおかつ、catchに指定した例外処理が記述されている
必要がある。

パッケージ済みのクラスで定義されているメソッドにも
throws節が付いたメソッドはたくさんあるため、
必ずtryの中で記述しないといけないものも今後出てくる？

すべての例外クラスはExceptionクラスを継承していますが、
このExceptionクラスを直に継承している例外クラスのメソッドはすべて
try~catchによる例外処理が必要になります。　
つまり、例外が発生したときにcatch内でしか呼び出せないメソッドですね。

逆にRuntimeExceptionクラスを継承している
例外クラスはすべて例外処理は不要となります。
try~catchを使わなくても、いけます。

つまり、RuntimeExceptionクラスは非チェック例外クラスであるので、
呼び出したメソッドの実行中にこの例外が発生しても、処理が止まらずに
メソッドの処理が中止されるだけで、呼び出し元のクラスで処理が継続される。
しかし、チェック例外クラスは
発生した時点でプログラムが停止してしまう。

ちなみに無理やり例外を発生させる方法もあり
throw new 例外クラス() という記述で例外を発生させることができます。
主に自作の例外を発生させるときなどに使います。
この記述をした場合は、必ずこの例外が発生する可能性があるということですので、
メソッドを定義したときに、throws節でその例外の発生を明記しておく必要があります。

しかし、RuntimeExceptionであれば、throwsで可能性を明記する必要はありません


